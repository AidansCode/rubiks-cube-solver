import rubik

def getPositionsFromPosition(position):
  #Returns all possible positons that can be reached from one quarter twist from the starting 'position'
  positions = set() #The set of positions that will be in the response
  for move in rubik.quarter_twists: #Loop through each possible move
    nextPosition = rubik.perm_apply(move, position) #Get the next position generated by this move
    positions.add((nextPosition, move)) #Store in positions the nextPosition generated by the current move as well as the move that got us there

  #Return the set of positions generated
  return positions

def getOverlap(list1, list2):
  #Given two lists of items, return the first item in list1 than is also in list 2
  for i in list1:
    if i in list2:
      return i
  return None

def buildPathFromStartToEnd(parentFront, parentEnd, middle):
  #Given a two 'parent' maps from a BFS search (one starting at the source vertex and one starting at the desired end vertex)
  #As well as a vertex that both parent maps have, generate a path from the start vertex
  #To the end vertex

  #This is the resulting path that will be returned. Will contain an ordered list of moves
  path = list()

  #Current node is our middle node that both parent objects have.
  curNode = middle
  while curNode: #Keep looping as long as we have a curNode
    #Get the parent of curNode in the front parent object
    parent = parentFront[curNode]
    #If parent[0] exists, there are moves needed before getting to curNode
    if (parent and parent[0]):
      #reset curNode for the next iteration of this loop
      curNode = parent[0]
      #Insert the move needed to get from the previous curNode to its parent at the beginning of our path
      path.insert(0, parent[1])
    else:
      #No more curNodes to go, break out
      break
  #Once this first while loop is done, we now have half of our path in 'path'

  #Current node is our middle node that both parent objects have.
  curNode = middle
  while curNode: #Keep looping as long as we have a curNode
    #Get the parent of curNode in the end parent object. Because this BFS search started from the end of the path,
    #the parent of curNode here is actually the vertex that comes after curNode in our final path
    parent = parentEnd[curNode]
    #If parent[0] exists, there are moves needed to get from curNode to its child
    if (parent and parent[0]):
      #reset curNode for the next iteration of this loop
      curNode = parent[0]
      #Since the new curNode actually comes after the previous curNode in our final path, we need to inverse the move
      #that is associated with it. Otherwise the second half of our final path would have the inverse of all of the correct moves
      inverseMove = rubik.perm_inverse(parent[1])
      #Insert our move into the end of our final path
      path.append(inverseMove)
    else:
      #No more curNodes, break out
      break
  #We've generated our path! Return it
  return path

def shortest_path(start, end):
  #Generates and returns an ordered list of moves from start to end, None if there is no possible path
  #Don't bother doing a BFS search if we're already at the end of the path. The result is simply a path of 0 moves
  if (start == end):
    return []

  #This is (almost) the same level/parent/frontier logic of a normal BFS search
  #There are two differences.
  #One: We are doing a BFS from the start and end so that we can meet in the middle (makes this much faster)
  #     Therefore we need a level/parent/frontier for each of the BFS searches (two total)
  #Two: The v of the k,v pair in the parent dictionaries is a tuple instead of a vertex. The
        #structure of the tuple is explained on each of their definitions
  levelFront = {start: 0}
  parentFront = {start: (None, None)} #Tuple is [0] = parent of start, [1] = move to get from parent to child
  frontierFront = [start]

  levelEnd = {end: 0}
  parentEnd = {end: (None, None)} #Tuple is [0] = parent of start, [1] = move to get from parent to child
  frontierEnd = [end]

  #Our current level
  i = 1

  #Keep going as long as we have vertices in either of our frontiers
  while len(frontierFront) > 0 or len(frontierEnd > 0):

    #Perform search on current level from front
    #nextFront will be the next frontier for our "front" BFS
    nextFront = []
    #Loop through all positions in our current front frontier
    for position in frontierFront:
      #Get all possible positions from position
      #Remember, each item in the list returned by getPositionsFromPosition is a tuple
      for nextPosition in getPositionsFromPosition(position):
        #If we haven't been to this position before
        if nextPosition[0] not in levelFront:
          #Store the position's level
          levelFront[nextPosition[0]] = i
          #Store the position's parent and the move that gets us from parent to the new position
          parentFront[nextPosition[0]] = (position, nextPosition[1])
          #Store our position in the next frontier
          nextFront.append(nextPosition[0])
    #We've finished going through this forntier, reset it for the next level
    frontierFront = nextFront

    #Perform search on current level from end
    #nextFront will be the next frontier for our "end" BFS
    nextEnd = []
    #Loop through all positions in our current end frontier
    for position in frontierEnd:
      #Get all possible positions from position
      #Remember, each item in the list returned by getPositionsFromPosition is a tuple
      for nextPosition in getPositionsFromPosition(position):
        #If we haven't been to this position before
        if nextPosition[0] not in levelEnd:
          #Store the position's level
          levelEnd[nextPosition[0]] = i
          #Store the position's parent and the move that gets us from parent to the new position
          parentEnd[nextPosition[0]] = (position, nextPosition[1])
          #Store our position in the next frontier
          nextEnd.append(nextPosition[0])
    #We've finished going through this forntier, reset it for the next level
    frontierEnd = nextEnd

    #Check if we have any overlap in our two parent objects. If there are, our two BFS searches
    #Have met in the middle and we've found a path from start to end
    overlap = getOverlap(parentFront, parentEnd)
    if overlap:
      #We've met in the middle! There's a path from start to end
      #Build the path and return it
      return buildPathFromStartToEnd(parentFront, parentEnd, overlap)

    #Increment our level for the next iteration
    i += 1
    #If we've reached beyond level 7 (8+), then there can be no path from start to end.
    #The maximum path is of length 14. If both BFS searches have gone over 7 levels then
    #They would have met in the middle by now if there was a possible path
    #Simply return None to reflect that there is no path from start to end
    if i > 7:
      return None

  #No solution found, simply return empty move list
  return None
